(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[766],{7620:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/projects/component",function(){return n(7981)}])},5334:function(e,t,n){"use strict";n.d(t,{Z:function(){return s}});var o=n(5893),i=n(9008),a=n.n(i);function s(e){let{title:t}=e;return(0,o.jsx)(a(),{children:(0,o.jsx)("title",{children:"George Thomas Shanti".concat(t?" | ".concat(t):"")})})}},6964:function(e,t,n){"use strict";n.d(t,{Z:function(){return i}});var o=n(5893);function i(e){let{children:t}=e;return(0,o.jsx)("main",{className:"bg-background min-h-screen pt-8 md:pt-20 text-lg font-content",children:(0,o.jsx)("div",{className:"mx-auto w-full p-6 md:w-5/6 lg:w-[60rem]",children:t})})}},7981:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return c}});var o=n(5893),i=n(5334),a=n(6964),s=n(1664),r=n.n(s);function c(){return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.Z,{}),(0,o.jsxs)(a.Z,{children:[(0,o.jsx)("h1",{className:"text-4xl md:text-6xl font-heading",children:"Component"}),(0,o.jsx)("div",{className:"mt-20",children:(0,o.jsxs)("div",{className:"[&>p]:my-8 indent-4 leading-16 text-justify",children:[(0,o.jsxs)("div",{className:"flex flex-row space-x-2",children:[(0,o.jsx)("a",{href:"https://github.com/georgeshanti/component",target:"_blank",rel:"noreferrer",className:"underline",children:"Github Repository"}),(0,o.jsx)("a",{href:"https://github.com/georgeshanti/component/tree/main/example",target:"_blank",rel:"noreferrer",className:"underline",children:"Example Project"}),(0,o.jsx)(r(),{href:"/blog/2023-02-22-lets-make-a-reactive-framework-pt-1",className:"underline",children:"Blog Post"})]}),(0,o.jsx)("p",{children:"I'd suggest reading this along with the github example project to get a better understanding of how this works. I still need to update the README to be better."}),(0,o.jsx)("p",{children:"In essence I tried to write my own reactive javascript library for a larger project I was working on. I didn't want to use existing frameworks because performance and customizability were some things I wanted prioritized. And using an existing framework would mean having to either structure a project around that framework and possibly it's limitations and restriction or modifying the framework to my liking which would then mean learning it inside out just to jerry-rig it. Neither of these sounded appealing and so I decided to write my own with customizability in mind but also since I myself am writing it, I wouldn't have to learn a whole new code base to change it to. I would just know just what to change since I wrote it myself."}),(0,o.jsx)("p",{children:"Component parses JSX during build-time to detect which parts of the jsx are static and which parts are state dependent. The static parts of the JSX are turned into a static HTML element and the dynamic parts of the JSX are turned into DOM manipulation statements specific to those parts of the element that change. So each block of JSX gets compiled into an object containing the static HTML element and a function to apply the dynamic changes to it."}),(0,o.jsxs)("p",{children:["So if you have a component that has a thousand elements and only one attribute in that changes. What would happen in a normal framework like ",(0,o.jsx)("b",{children:"React"})," that uses a Virtual DOM is, it will make a 1000 calls to document.createElement and then everytime that one attribute would change it would call the diff algorithm a 1000 times, but only one of those diff operations would result in a meaningful dom manipulation. Component on the other hand will convert the JSX block emit one static HTML elememt with the 1000 elements already in it, meaning only one diff algorithm call to see if it must re-use the old entity and a function with exactly one dom manipualtion statement in it to change the value of that one attribute dynamically."]}),(0,o.jsxs)("p",{children:["This is also how ",(0,o.jsx)("b",{children:"SolidJS"})," operates."]}),(0,o.jsx)("p",{children:"But where this differes from Solid is that while solid uses hooks like in React, I chose to move in the direction of components with life cycle methods because that just seemed simpler to me. You wouldn't to learn how hooks worked and how hooks could be used a life cycle methods for your component. Class components that have specific life cycle methods that did what you would expect them to do is simpler. Plus local state would actually be state stored local to the component and not some external aspect accessed by a hook. Just more intuitive."}),(0,o.jsxs)("p",{children:["But most importantly, I added a component that in itself is an escape hatch from this system. ",(0,o.jsx)("code",{children:"<Sub />"}),", short for substitute. You can use this component to embed any other HTML Element you want and that element will not be subject to the diff algorithm and state management of component library. So if you want to use another UI library all you have to do is attach the component generated by that library to a ",(0,o.jsx)("code",{children:"<Sub />"})," component. Since this element is not affected byt the component system you can move it to different ",(0,o.jsx)("code",{children:"<Sub />"})," components within the project and it will still remain the same but just in a different part of the HTML Tree."]}),(0,o.jsxs)("p",{children:["An added benefit is that any component you build with this library will have it's corresponding HTML element attached to the instance of that component object. So what this means is that you can create an instance of a Component, retrieve the HTML element and pass it to a ",(0,o.jsx)("code",{children:"<Sub />"})," component. This means you can move whole components within the tree while still preserving it's state. Because the Component instance inside the <Sub /> component has it's own state independent of the outer state. The two cannot interfere with each other."]})]})})]})]})}}},function(e){e.O(0,[996,774,888,179],function(){return e(e.s=7620)}),_N_E=e.O()}]);