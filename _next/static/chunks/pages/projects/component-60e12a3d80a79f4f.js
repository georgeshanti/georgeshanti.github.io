(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[766],{7620:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/projects/component",function(){return n(7981)}])},5334:function(e,t,n){"use strict";n.d(t,{Z:function(){return r}});var o=n(5893),a=n(9008),i=n.n(a);function r(e){let{title:t}=e;return(0,o.jsx)(i(),{children:(0,o.jsx)("title",{children:"George Thomas Shanti".concat(t?" | ".concat(t):"")})})}},6964:function(e,t,n){"use strict";n.d(t,{Z:function(){return a}});var o=n(5893);function a(e){let{children:t}=e;return(0,o.jsx)("main",{className:"bg-background min-h-screen pt-8 md:pt-20 text-lg font-content",children:(0,o.jsx)("div",{className:" mx-auto w-full p-6 md:w-5/6 lg:w-[60rem] [&>h1]:text-4xl [&>h1]:font-heading [&>h1]:mb-16 [&>h2]:text-3xl [&>h2]:font-heading [&>h2]:mb-4 [&>h3]:text-3xl [&>h3]:font-heading [&>h3]:mb-2 [&>p]:my-8 [&>p]:indent-4 [&>p]:leading-16 [&>p]:text-justify [&>pre]:bg-gray-700 [&>pre]:text-white [&>pre]:font-monospace [&>pre]:px-8 [&>pre]:py-6 [&>pre]:rounded-lg [&>pre]:overflow-x-scroll [&>p>code]:text-red [&>p>code]:inline-block [&>p>code]:px-2 [&>p>code]:rounded [&>p>code]:bg-gray-300 [&>p>code]:indent-0 ",children:t})})}},7981:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return l}});var o=n(5893),a=n(5334),i=n(6964),r=n(1664),s=n.n(r);function l(){return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.Z,{}),(0,o.jsxs)(i.Z,{children:[(0,o.jsx)("h1",{className:"text-4xl md:text-6xl font-heading",children:"Component"}),(0,o.jsx)("a",{href:"https://github.com/georgeshanti/component",target:"_blank",rel:"noreferrer",className:"underline",children:"Github Repository"}),"\xa0\xa0\xa0",(0,o.jsx)("a",{href:"https://github.com/georgeshanti/component/tree/main/example",target:"_blank",rel:"noreferrer",className:"underline",children:"Example Project"}),"\xa0\xa0\xa0",(0,o.jsx)(s(),{href:"/blog/2023-02-22-lets-make-a-reactive-framework-pt-1",className:"underline",children:"Blog Post"}),(0,o.jsx)("p",{children:"Component is a reactive javascript library."}),(0,o.jsx)("p",{children:(0,o.jsx)("i",{children:"Note: I will refer to React a lot because that is the library I am most familiar with. So a lot of the things I do in this project comes from the perspective of someone who is heavily influenced by React."})}),(0,o.jsx)("h3",{children:"How does it work?"}),(0,o.jsxs)("p",{children:["The biggest difference between Component and React is how rendering is handled. React components create a tree of elements for each block of JSX. Each node of this tree represents an element, either an HTML element, a React Component or a Fragment. Note that these aren't the elements themselves, these are simply representations of them. The actually rendering of them is handled by the ",(0,o.jsx)("code",{children:"ReactDOM.render()"})," function, where it takes this tree, runs its diff algorithm on it to generate/modify the actual HTML element that it corresponds to and then recursively calls this render function on the children of each node of the tree to finally create the complete HTML you see on on your browser screen. So react will start calling the render function and run it's diff algorithm and element generation of each individual element whether it changes on not. Now any component you write is mostly static. Most of the elements within your component will not change during the course of its life, you'll change some styles and swap between other components and HTML elements. But it is very unlikely that your changing parts will outnumber your static parts. Now react assumes everybit of your component can change at any moment so this is why it does this."]}),(0,o.jsx)("p",{children:"How component does this is very different. It parses each block of JSX during build time to convert all the static parts into a static HTML element that will act as a template and converts all the dynamic parts into a function that applies those changes to that template. So each block will only get diffed at it's root to see if it's the same template as before. Internal elements that are know to be unchanging are not examined during runtime. Component does this with a babel plugin."}),"The source of a component and output of it in react and component:",(0,o.jsx)("pre",{children:(0,o.jsx)("code",{children:'// Source\nfunction Component(){\n  return (\n    <div style="background: green">\n      <p>Hello, world!</p>\n      <br/>\n      <NestedComponent propName={propValue}/>\n      {condition?(<span />):(<div />)}\n    </div>\n  )\n}'})}),(0,o.jsx)("br",{}),(0,o.jsx)("br",{}),(0,o.jsx)("pre",{children:(0,o.jsx)("code",{children:"// React Output\nfunction Component(){\n  return React.createElement('div', {'style': 'background: green'},\n    React.createElement('p', {}, 'Hello, world!'),\n    React.createElement('br'),\n    React.createElement(NestedComponent, {'propName': propValue})\n    condition?React.createElement('span'):React.createElement('div'),\n  );\n}"})}),(0,o.jsx)("br",{}),(0,o.jsx)("br",{}),(0,o.jsx)("pre",{children:(0,o.jsx)("code",{children:'// Component Output\n\n// The generated templates\nconst template0 = template(\n  "<div style="background: green"><p>Hello, world!</p><br></div>",\n  (domElement) => {\n    elm0: domElement,\n    elm1: domElement.firstChild.nextSibling.nextSibling\n  }\n);\nconst template1 = template(\n  "<span></span>",\n  (domElement) => {}\n);\nconst template2 = template(\n  "<div></div>",\n  (domElement) => {}\n);\n\nfunction Component(){\n\n  // Root div element\n  return {\n    type: "template",\n    template: template0,\n    templateFunction: (templateState, context)=>{\n      let anchor = { node: elm1 };\n\n      // The NestedComponent\n      templateState.children[0] = compareAndCreate(\n        templateState.children[0],\n        {\n          type: "component",\n          component: NestedComponent\n        },\n        elm0,\n        anchor\n      )\n\n      // The conditional expression\n      templateState.children[1] = compareAndCreate(\n        templateState.children[1],\n        condition?\n          {\n            type: "template",\n            template: template1,\n            templateFunction: (templateState, context)=>{}\n          }:\n          {\n            type: "template",\n            template: template2,\n            templateFunction: (templateState, context)=>{}\n          },\n        elm0,\n        anchor\n      )\n    }\n  }\n}'})}),(0,o.jsx)("p",{children:"Now the output of the component code looks very large and complicated. It's just really verbose. What's happening is that component takes every root JSX element and creates a new template so JSX blocks that are contained within expressions also get converted into templates. I could make this a lot less verbose but I just haven't gotten around to it. I shall eventually."}),(0,o.jsx)("p",{children:"SolidJS does this same thing but the final output looks much nicer. I'll get there. But what component does differently is in how it manages component lifecycle. SolidJS uses hooks. I chose not to use hooks and instead chose to make them classes with life cycle methods like in the early days of React. This approach seemed more intuitive to me."}),(0,o.jsx)("p",{children:"State is not something that resides outside of your component that you access and manage using a hook. Normally, the state of any object is the object itself, the fields/values of that object. So the state of your component is just the fields of that class. There is no special state field. There's just a rerender method that initiates a re-render of your component once you've changed state."}),(0,o.jsx)("h3",{children:"Some things it does entirely differently"}),(0,o.jsx)("p",{children:"I think the biggest difference in component and other libraries is how component can be used in code that isn't component code and vice versa. What enables this is:"}),(0,o.jsxs)("ol",{className:"list list-outside list-decimal",children:[(0,o.jsxs)("li",{children:["Every component has a ",(0,o.jsx)("code",{children:"getDomElement()"})," method which will return the HTML Element that is generated by that component. And so you can go place this HTML element anywhere you want in your exising UI."]}),(0,o.jsxs)("li",{children:["There is a special component ",(0,o.jsx)("code",{children:"<Sub child={}/>"})," with a prop ",(0,o.jsx)("code",{children:"child"})," that accepts an HTML Element and it just places that HTML element wherever Sub is and this element will not be subject to the diff algorithm. It will exist as it is and it can be manipulated directly as you please. So you can use any 3rd part libraries you want with this."]}),(0,o.jsxs)("li",{children:["Comibing the two things above, what you can do is create a component, get its HTML Element with getDomElement() and then place that in any ","<Sub />"," component you want anywhere in your app thereby moving the component within the tree while still preseriving the state of that component."]})]}),(0,o.jsx)("br",{}),(0,o.jsx)("h3",{children:"Why did I go through the trouble of doing all this?"}),(0,o.jsx)("p",{children:"In essence I tried to write my own reactive javascript library for a larger project I was working on. I didn't want to use existing frameworks because performance and customizability were some things I wanted prioritized. And using an existing framework would mean having to either structure a project around that framework and possibly it's limitations and restriction or modifying the framework to my liking which would then mean learning it inside out just to jerry-rig it. Neither of these sounded appealing and so I decided to write my own with customizability in mind but also since I myself am writing it, I wouldn't have to learn a whole new code base to change it to. I would just know just what to change since I wrote it myself."})]})]})}}},function(e){e.O(0,[996,774,888,179],function(){return e(e.s=7620)}),_N_E=e.O()}]);