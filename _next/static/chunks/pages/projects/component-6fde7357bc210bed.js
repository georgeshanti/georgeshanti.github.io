(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[766],{7620:function(t,e,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/projects/component",function(){return n(7981)}])},5334:function(t,e,n){"use strict";n.d(e,{Z:function(){return s}});var o=n(5893),i=n(9008),a=n.n(i);function s(t){let{title:e}=t;return(0,o.jsx)(a(),{children:(0,o.jsx)("title",{children:"George Thomas Shanti".concat(e?" | ".concat(e):"")})})}},6964:function(t,e,n){"use strict";n.d(e,{Z:function(){return i}});var o=n(5893);function i(t){let{children:e}=t;return(0,o.jsx)("main",{className:"bg-background min-h-screen pt-8 md:pt-20 text-lg font-content",children:(0,o.jsx)("div",{className:"mx-auto w-full p-6 md:w-5/6 lg:w-[60rem]",children:e})})}},7981:function(t,e,n){"use strict";n.r(e),n.d(e,{default:function(){return h}});var o=n(5893),i=n(5334),a=n(6964),s=n(1664),r=n.n(s);function h(){return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.Z,{}),(0,o.jsxs)(a.Z,{children:[(0,o.jsx)("h1",{className:"text-4xl md:text-6xl font-heading",children:"Component"}),(0,o.jsx)("div",{className:"mt-20",children:(0,o.jsxs)("div",{className:"[&>p]:my-8 indent-4 leading-16 text-justify",children:[(0,o.jsx)("a",{href:"https://github.com/georgeshanti/component",target:"_blank",rel:"noreferrer",className:"underline",children:"Github Repository"}),"\xa0\xa0\xa0\xa0\xa0",(0,o.jsx)(r(),{href:"/blog/2023-02-22-lets-make-a-reactive-framework-pt-1",className:"underline",children:"Blog Post"}),(0,o.jsx)("p",{children:"I'd suggest reading this along with the github example project to get a better understanding of how this works. I still need to update the README to be better."}),(0,o.jsx)("p",{children:"In essence I tried to write my own reactive javascript library for a larger project I was working on. I didn't want to use existing frameworks because performance and customizability wer some things I wanted prioritized. And using an existing framework would mean having to either structure a project around that framework and possibly it's limitations and restriction or modifying the framework to my liking which would then mean learning it inside out just to jerry rig it. Neither of thse sounded appealing and so I decided to write my own with customizability in mind but also since I myself am writing it, I wouldn't have to learn a whole new code base to change it to. I would just know just what to change since I myself wrote it."}),(0,o.jsx)("p",{children:"Component is a reactive javascript library that parses JSX during build-time to detect which parts of the jsx are static and which parts are state dependent. The static parts of the JSX are turned into a static HTML element and the dynamic parts of the JSX are turned into DOM manipulation statements specific to those parts of the element that change. So each block of JSX gets compiled into an object containing the static HTML element and a function to apply the dynamic changes to it."}),(0,o.jsxs)("p",{children:["So if you have a component that has a thousand elements and only one attribute in that changes. What would happen in a normal framework like ",(0,o.jsx)("b",{children:"React"})," that uses a Virtual DOM is, it will make a 1000 calls to document.createElement and then everytime that one attribute would change it would call the diff algorithm a 1000 times, but one one of those diff operations would result in a meaningful dom manipulation. Component on the other hand will convert the JSX block emit one static HTML elememt with the 1000 elements already in it, meaning only one diff algorithm call to see if it must re-use the old entity and a function with exactly one dom manipualtion statement in it to change the value of that one attribute dynamically."]}),(0,o.jsxs)("p",{children:["This is how ",(0,o.jsx)("b",{children:"SolidJS"})," operates."]}),(0,o.jsx)("p",{children:"But where this differes from Solid is that while solid uses hooks like in React, I chose to move in the direction of components with life cycle methods because that just seemed more natural to me. You wouldn't to learn how hooks worked and how hooks could be used a life cycle methods for your component. Class components with life cycle methods just seemed more intuitive. Plus local state would actually be state local to the component and not some external aspect accessed by a hook. Just more intuitive."}),(0,o.jsx)("p",{children:"But most importantly, I added a component that in itself is an escape hatch from this system <Sub />, for substitute. You can use this component to embed any other HTML Element you want and that element will not be subject to the diff algorithm and state management of component. So if you want to use another UI library all you have to do is attach the component generated by that library to a <Sub /> component. Since this element is not affected byt the component system you can move it to different Sub components within the Component project and it will still remain the same but just in a different part of the HTML Tree."}),(0,o.jsx)("p",{children:"An added benefit is that any component you build with this library will have it's corresponding HTML element attached to the instance of that component object. So what this means is that you can create an instance of a Component and pass it's HTML Element to a <Sub /> component. This means you can move whole components within the tree while still preserving it's state. Because the Component instance inside the <Sub /> component has it's own diff algorithm independant of the outer diff algorith. The two cannot interfere with each other."})]})})]})]})}}},function(t){t.O(0,[996,774,888,179],function(){return t(t.s=7620)}),_N_E=t.O()}]);