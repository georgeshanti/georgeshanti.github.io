<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>George Thomas Shanti</title><meta name="next-head-count" content="3"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/favicon.ico"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/d4548e9c43eae31e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d4548e9c43eae31e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-f11614d8aa7ee555.js" defer=""></script><script src="/_next/static/chunks/pages/_app-bf55c49910772dbb.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-85b6bc21d21a50df.js" defer=""></script><script src="/_next/static/1mZEgSQn3qenuh9xFH6Kn/_buildManifest.js" defer=""></script><script src="/_next/static/1mZEgSQn3qenuh9xFH6Kn/_ssgManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css2?family=Gloock&display=swap">@font-face{font-family:'Gloock';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/gloock/v1/Iurb6YFw84WUY4N5jA.woff) format('woff')}@font-face{font-family:'Gloock';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/gloock/v1/Iurb6YFw84WUY4NJhRakJLRBjIlJ.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Gloock';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/gloock/v1/Iurb6YFw84WUY4NJhhakJLRBjIlJ.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Gloock';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/gloock/v1/Iurb6YFw84WUY4NJiBakJLRBjA.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style><style data-href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@200;300;400;500&display=swap">@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngbUXZYTXPIvIBgJJSb6s3BzlRRfKOFbvjoDISWaw.woff) format('woff')}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngbUXZYTXPIvIBgJJSb6s3BzlRRfKOFbvjo0oSWaw.woff) format('woff')}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngbUXZYTXPIvIBgJJSb6s3BzlRRfKOFbvjojISWaw.woff) format('woff')}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngbUXZYTXPIvIBgJJSb6s3BzlRRfKOFbvjovoSWaw.woff) format('woff')}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufA5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufJ5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufB5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufO5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufC5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufD5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:200;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufN5qWr4xCC.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufA5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufJ5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufB5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufO5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufC5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufD5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufN5qWr4xCC.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufA5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufJ5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufB5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufO5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufC5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufD5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufN5qWr4xCC.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufA5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufJ5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufB5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufO5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufC5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufD5qWr4xCCQ_k.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto Slab';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/robotoslab/v24/BngMUXZYTXPIvIBgJJSb6ufN5qWr4xCC.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body class="text-black"><div id="__next"><main class="bg-background min-h-screen pt-8 md:pt-20 text-lg font-content"><div class="mx-auto w-full p-6 md:w-5/6 lg:w-[60rem]"><div class=" [&amp;&gt;h1]:text-4xl [&amp;&gt;h1]:font-heading [&amp;&gt;h1]:mb-16 [&amp;&gt;h2]:text-2xl [&amp;&gt;h2]:font-heading [&amp;&gt;h2]:mb-4 [&amp;&gt;h3]:text-xl [&amp;&gt;h3]:font-heading [&amp;&gt;h3]:mb-2 [&amp;&gt;p]:my-8 [&amp;&gt;p]:indent-4 [&amp;&gt;p]:leading-16 [&amp;&gt;p]:text-justify [&amp;&gt;pre]:bg-gray-700 [&amp;&gt;pre]:text-white [&amp;&gt;pre]:font-monospace [&amp;&gt;pre]:px-8 [&amp;&gt;pre]:py-6 [&amp;&gt;pre]:rounded-lg "><h1>1. Let's make a reactive framework Pt-1</h1>
<p>It is javascript library to build a reactive frontend for the web. Sounds like React and every other Reactive Javascript library out there? That's because it is.</p>
<p>It actually started because I wanted to build a devtool for myself(it's a secret) and performace and customizability was something I wanted as part of the whatever frontend framework I used. But I read about how other projects similar to the one I had in mind refrained from using any framework because they didn't want to tied down by the restrictions of the framework and didn't want to hunt down performance issues caused by it. Now I could just write everything I wanted in vanilla javascript and propogate changes in the UI with individual DOM Manipulation calls. But reactive systems like React had spoilt me. I couldn't go back to writing lines and lines of DOM manipulation just to change the look of a few UI components. So I decided to write my own reactive framework. Atlest this way if there was any performance issue I could just look at my own code and fix it instead having to go through the mammoth codebase that is react to figure out how to change something. Idk how big react is, I haven't checked.</p>
<p>Ok so off to the races, we basically need to write our own version of react. Setup a typescript project. Write some tsx files. The typescript compiler will let you know you don't have anything in place to process jsx yet. So then you do a bit of research and find out that you can add a function that will turn jsx into functin calls and basics of it can be figured out just through linter and build errors. After a couple of days of trying, I figured out how React worked, atleast I think this is how react works. Some bits I had to cheat to understand by console logging some of the functions React provides and some I sort of had a vague understanding of which helped when I really thought about it. This is sort of how it went.</p>
<p>We'll use the following snippet as our test code:</p>
<pre><code>function InternalComponent(name){
    console.log("Inside InternalComponent");
    return (&#x3C;span>Hello {name}&#x3C;/span>);
}

function App(){
    console.log("Inside App");
    return (&#x3C;div>&#x3C;InternalComponent name="George" />&#x3C;/div>);
}
</code></pre>
<p></p>
<h2>How react renders each element</h2>
<p>React converts each JSX element into a function call. So &#x3C;div> turns into React.createElement('div') and components like &#x3C;App/> turns into React.createElement(App). So I write my jsx rendering function that will take the element, either a string for an HTML element or an identifier for a Component element, props for the element and it's children. If it is an HTML element, then it will create HTML element with document.createElement, set it's properties and append the children passed to it, and return the element. If it's a component then run the component function by passing the properties and children to the function and return the element returned by that component. This will happen recursively and I tried it out. It all works great. UI is rendering exactly How I want it to.</p>
<p>Basic implementation of createElement is this.:</p>
<pre><code>function createElement(element, props, ...children){
    if(typeof element === 'string'){
        // This means this is an HTML Element

        let e = document.createElement(element);\

        // Set attribute and event listeners according to the props
        // e.setAttribute("", "")
        // e.onEvent(eventHandler)

        // Append children to element
        for(let child of children){
            e.appendChild(child)
        }

        return e;
    }else{
        // This means a function component was passed

        return element({...props, children});
    }
}
</code></pre>
<p>Compiler output is</p>
<pre><code>function InternalComponent(){
    console.log("Inside InternalComponent");
    return createElement('span', {}, 'Hello', name);
}

function App(){
    console.log("Inside App");
    return createElement('div', {}, createElement(InternalComponent, {"name": "George"}));
}
</code></pre>
<p>And when I run it console prints:</p>
<pre><code>Inside App
Inside InternalComponent
</code></pre>
<p></p>
<h2>How react maintains state and re-renders each element</h2>
<p>State means we can store certains things persistantly and change it and have that change persist. So if we make our JSX dependent on the state then we can manipulate our JSX by manipulating the state. Ok now we need to change the JSX function to not just return the element but also create a tree(the Virtual Dom in react) of that element so that when something changes in the returned tree from the original tree we can run the dom manipulation to change it in the actual page. So when state changes, the tree changes, that in turn changes the page with DOM function(simple diff algorithm, not very complicated). Also very doable. Done. Now we need to add a way access and mutate state.</p>
<p>How react does this is with a function called useState. useState returns the value of the state and a setState function to the set that state. Now this seems simple, all you need is a function that when you pass a value to, stores this value somewhere, returns that value, together a function that updates the stored value and re runs the function that called useState. When you call setState, it reruns that same component function but this time the call to useState will return the updated value and again the setState function</p>
<p>Looks sort of like this:</p>
<pre><code>function App(){
    console.log("Inside App");
    const [name, setName] = useState("George");

    return (&#x3C;div onClick={()=>{setName("Thomas")}}>{name}&#x3C;/div>)
}
</code></pre>
<p>At first the text will be George but then when you click on the div it will change to Thomas.</p>
<p>But the thing to realise here is that useState is a global function. The value that's being stored or updated depends on the function that called useState which is essentially a local function but useState in itself is a global function. When you call the setState function, how does React know which components useState this call corresponds to.</p>
<p>There's nothing you do in your component that tells useState "Hey this function right here the reference to this function that's being run right now. This is what you need to rerender when i call the setState you give me." But there's no way to do this. There's no way for useState to implicitly get a reference to the function that's calling it. But there is another function that does know.</p>
<p>The createElement() function is what actually calls the component function. So what we can do is make createElement update the global useState to be a function that stores state, generate a function that updates stored state and re runs the function component passed to createElement.</p>
<p>The updated createElement will look like this:</p>
<pre><code>const useState: (value: T)=>[value, (value)=>void];

function createElement(element, props, ...children){
    if(typeof element === 'string'){
        // This means this is an HTML Element

        let e = document.createElement(element);\

        // Set attribute and event listeners according to the props
        // e.setAttribute("", "")
        // e.onEvent(eventHandler)

        // Append children to element
        for(let child of children){
            e.appendChild(child)
        }

        return e;
    }else{
        // This means a function component was passed

        let componentStates = [];
        let stateIndex = 0;
        useState = (initialValue)=>{
            if(componentStates.length==stateIndex){
                // This means this is the first time useState has been called for this state value
                // So we store the initial value of state
                componentStates.push(initialValue)
            }
            let currIndex = stateIndex;
            stateIndex++;
            return [
                componentStates[currIndex],
                (newValue)=>{
                    componentStates[currIndex] = newValue;
                    element({...props, children})
                }
            ];
        }
        return element({...props, children});
    }
}
</code></pre>
<p>The createElement function isn't actually so simple, it also has the actual diff algorithm that compares old element type and new element type to figure out if it is a new element and if it isn't then to discard old state and so on. But I've skipped that bit for now.</p>
<p>createElement will maintain a list of state values of each component and useState will use and update that list of states to figure out whether to initialize state or to return existing state. stateIndex helps useState keep track of which state value is being initialized or updated. So when you update a state value, it calls the function again and this time when it calls useState it has the updated list of states.</p>
<p>This is not actually how I implemented this functionality, the re-render wasn't called quite so simple either, especially with the complication we will be discussing next. I honestly don't remember how I did it and there's not way to know since I scrapped this and moved to a different approach which we will discuss to later.</p>
<p>Now it looks like state is implement, we call createElement, that sets up state vairables and the it calls the function component that calls useState and it's all hunky dory. Sadly no, if we go back to the original compiler output and examine the two compiled JSX lines.</p>
<pre><code>// Inside App
    return createElement('div', {}, createElement(InternalComponent, {"name": "George"}));
</code></pre>
<p>When the createElement inside App is called, it will first evaluate the createElement function calls that are passed as children to it. That's just the order of evaluation that needs to happen. It cannot call the first createElement without first knowing everything that needs to be passed which means evaluating the second createElement. What this means is that in a given block of JSX, the createElement for children are evaluated before the parents and lastly the root element of that Block.</p>
<p>So each time the a function component is rendered. This is what happens:</p>
<ul>
<li>createElement for a the function component is first called.</li>
<li>Then the function component is called.</li>
<li>Then the return expression ie. the JSX block must be evaluated. This a series of createElement calls.</li>
<li>The way it is structured, the createElements of the leaf nodes in the block of JSX needs to be evaluated first before it's parents within that JSX block can be executed.</li>
<li>createElements of the JSX block are called in a bottom up fashion.</li>
<li>Whenever a node within the JSX block is another function component, this cycle continues again for that function component before continuing with the original function components cycle.</li>
</ul>
<p>What this results in is a weird call system where the component functions are called in a sort of top-down manner but the createElements within a JSX block is called in a bottom-up manner. This was causing a huge problem when I implemented the useState function. I can't now recall what that huge problem is because that was back in November 2022 and now it's February 2023. Basically what happened was because of this fuck-all order of evaluation I wasn't able to call the right function component to re-render when setState was called. But looking at what I've written now I can't seem to figure out why that was the case.</p>
<p>Now it this next bit seems kind of useless because I can't remember what it actually solves....... but I guess we carry on anyway</p>
<p>WHat I think the problem was is..... I mentioned earlier on in the post that this createElement function also implemented the diff algorithm to make DOM manipulations. I've only written the creationof the element and the setting of attributes and listeners. Which is the part of the diff algorithm that runs when there was no existing element. When there already is one it compares and then either discards or retains the element and applies changes to it dynamically. The mixed up top-down manner of function component calls and and bottom up manner of the jsx evalution got in the way of the diff algorith working properly. So we needed to have everything be called in a proper top-down manner so that the diff will also take place in a top-down manner.</p>
<h2>How react actually and re-renders each element</h2>
<p>Ok we need it to only be top down, we can't have the JSX be evaluting itself in the bottom up manner. I don't know how I realsied this but I did. I realised that the evaluation of the child jsx elements needs to be run inside the evaluation of the parent jsx elements and not outide and before it. So internal createElements need to be deferred. But this isn't possible, the order of evaluation just won't allow for that.</p>
<p>But if we really think about it, it's not that we want child createElements to be run by the parent. We want what createElement currently does for child elements to be called by parent elements. So what we need to do is move the component creation and evalution out of createElement. So what will createElement? Well in essence nothing. We ideally want it to return a function that then does what our original createElement did, let's call this the internal function. So now createElement no longer returns a child. Instead it returns a fucntion that creates a child. This also means that the children passed to a createElement call are not the actual children elements, they are functions that when called will return the corresponding child elements. So instead of just appending the child in the internal function like we do in the original createElement function, we must first run the function to get the element and then append it to the parent.</p>
<p>This means that the node creation, setting of attributes and event listeners within a JSX block is now carried out in a top down manner becuase internal functions of children are only evaluated within the internal functions of parents.</p>
<pre><code>const useState: (value: T)=>[value, (value)=>void];

function createElement(element, props, ...children){
    return () => {
        if(typeof element === 'string'){
            // This means this is an HTML Element

            let e = document.createElement(element);\

            // Set attribute and event listeners according to the props
            // e.setAttribute("", "")
            // e.onEvent(eventHandler)

            // Evaluate children and append to element
            for(let child of children){
                e.appendChild(child())
            }

            return e;
        }else{
            // This means a function component was passed

            let componentStates = [];
            let stateIndex = 0;
            useState = (initialValue)=>{
                if(componentStates.length==stateIndex){
                    // This means this is the first time useState has been called for this state value
                    // So we store the initial value of state
                    componentStates.push(initialValue)
                }
                let currIndex = stateIndex;
                stateIndex++;
                return [
                    componentStates[currIndex],
                    (newValue)=>{
                        componentStates[currIndex] = newValue;
                        element({...props, children})
                    }
                ];
            }
            return element({...props, children});
        }
    };
}
</code></pre>
<p>React actually doesn't do it like this. It actually separates the the createElement and internal function into two separate non-nested functions. createElement just returns and object of the element type, it's props and it's children in this same object format so it returns a recursive top down tree of the JSX block. This object is passed to a function ReactDOM.render, which carries out the function of the internal function we wrote and instead of calling the children functions, since they are not functions any more, now they are these tree objects, it calls ReactDOM.render on these children objects as well to get the corresponding HTML element to append to the child. We've all seen this ReactDOM.render element in the index.js file of our react apps.</p>
<p>Fascinating stuff. I'm sure I made very little sense in this post but if you want a explaination feel free to hit me up on twitter.</p>
<p>We're not done yet though, I decided to drop this approach. I realised that since I have to call createElement for every single jsx element in my app and run the diff algorithm on every single one of them(comparing old props and new props to know which attributes, styles and event handlers to change) and all this runs at runtime. The thing is that 90% of these elements never change in any of these aspects. Sure components might get added and removed depending on the state but when you take any single component about 90% of it is not state dependent. But the dynamic nature of the diff algorithm assumes every aspect of a component can be dependent on state and carries out these tree comparisons on ever single node. And this diff algorithm can be expensive, maybe not for 90% of projects out there becuase Virtual DOM diffing is still several degrees faster than HTMl DOM diffing. But when you consider how much of the diff actually results in DOM manipulations and how much of it leaves an HTML element as it is, you will realise just how much unnecessary work is being done in diffing static components.</p>
<p>So I gave up and decided to go back to Vanilla Javascript. Until I thought of something else which we will talk about in Part-2.....</p>
</div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"\u003ch1\u003e1. Let's make a reactive framework Pt-1\u003c/h1\u003e\n\u003cp\u003eIt is javascript library to build a reactive frontend for the web. Sounds like React and every other Reactive Javascript library out there? That's because it is.\u003c/p\u003e\n\u003cp\u003eIt actually started because I wanted to build a devtool for myself(it's a secret) and performace and customizability was something I wanted as part of the whatever frontend framework I used. But I read about how other projects similar to the one I had in mind refrained from using any framework because they didn't want to tied down by the restrictions of the framework and didn't want to hunt down performance issues caused by it. Now I could just write everything I wanted in vanilla javascript and propogate changes in the UI with individual DOM Manipulation calls. But reactive systems like React had spoilt me. I couldn't go back to writing lines and lines of DOM manipulation just to change the look of a few UI components. So I decided to write my own reactive framework. Atlest this way if there was any performance issue I could just look at my own code and fix it instead having to go through the mammoth codebase that is react to figure out how to change something. Idk how big react is, I haven't checked.\u003c/p\u003e\n\u003cp\u003eOk so off to the races, we basically need to write our own version of react. Setup a typescript project. Write some tsx files. The typescript compiler will let you know you don't have anything in place to process jsx yet. So then you do a bit of research and find out that you can add a function that will turn jsx into functin calls and basics of it can be figured out just through linter and build errors. After a couple of days of trying, I figured out how React worked, atleast I think this is how react works. Some bits I had to cheat to understand by console logging some of the functions React provides and some I sort of had a vague understanding of which helped when I really thought about it. This is sort of how it went.\u003c/p\u003e\n\u003cp\u003eWe'll use the following snippet as our test code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction InternalComponent(name){\r\n    console.log(\"Inside InternalComponent\");\r\n    return (\u0026#x3C;span\u003eHello {name}\u0026#x3C;/span\u003e);\r\n}\r\n\r\nfunction App(){\r\n    console.log(\"Inside App\");\r\n    return (\u0026#x3C;div\u003e\u0026#x3C;InternalComponent name=\"George\" /\u003e\u0026#x3C;/div\u003e);\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eHow react renders each element\u003c/h2\u003e\n\u003cp\u003eReact converts each JSX element into a function call. So \u0026#x3C;div\u003e turns into React.createElement('div') and components like \u0026#x3C;App/\u003e turns into React.createElement(App). So I write my jsx rendering function that will take the element, either a string for an HTML element or an identifier for a Component element, props for the element and it's children. If it is an HTML element, then it will create HTML element with document.createElement, set it's properties and append the children passed to it, and return the element. If it's a component then run the component function by passing the properties and children to the function and return the element returned by that component. This will happen recursively and I tried it out. It all works great. UI is rendering exactly How I want it to.\u003c/p\u003e\n\u003cp\u003eBasic implementation of createElement is this.:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction createElement(element, props, ...children){\r\n    if(typeof element === 'string'){\r\n        // This means this is an HTML Element\r\n\r\n        let e = document.createElement(element);\\\r\n\r\n        // Set attribute and event listeners according to the props\r\n        // e.setAttribute(\"\", \"\")\r\n        // e.onEvent(eventHandler)\r\n\r\n        // Append children to element\r\n        for(let child of children){\r\n            e.appendChild(child)\r\n        }\r\n\r\n        return e;\r\n    }else{\r\n        // This means a function component was passed\r\n\r\n        return element({...props, children});\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCompiler output is\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction InternalComponent(){\r\n    console.log(\"Inside InternalComponent\");\r\n    return createElement('span', {}, 'Hello', name);\r\n}\r\n\r\nfunction App(){\r\n    console.log(\"Inside App\");\r\n    return createElement('div', {}, createElement(InternalComponent, {\"name\": \"George\"}));\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd when I run it console prints:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eInside App\r\nInside InternalComponent\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003ch2\u003eHow react maintains state and re-renders each element\u003c/h2\u003e\n\u003cp\u003eState means we can store certains things persistantly and change it and have that change persist. So if we make our JSX dependent on the state then we can manipulate our JSX by manipulating the state. Ok now we need to change the JSX function to not just return the element but also create a tree(the Virtual Dom in react) of that element so that when something changes in the returned tree from the original tree we can run the dom manipulation to change it in the actual page. So when state changes, the tree changes, that in turn changes the page with DOM function(simple diff algorithm, not very complicated). Also very doable. Done. Now we need to add a way access and mutate state.\u003c/p\u003e\n\u003cp\u003eHow react does this is with a function called useState. useState returns the value of the state and a setState function to the set that state. Now this seems simple, all you need is a function that when you pass a value to, stores this value somewhere, returns that value, together a function that updates the stored value and re runs the function that called useState. When you call setState, it reruns that same component function but this time the call to useState will return the updated value and again the setState function\u003c/p\u003e\n\u003cp\u003eLooks sort of like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction App(){\r\n    console.log(\"Inside App\");\r\n    const [name, setName] = useState(\"George\");\r\n\r\n    return (\u0026#x3C;div onClick={()=\u003e{setName(\"Thomas\")}}\u003e{name}\u0026#x3C;/div\u003e)\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt first the text will be George but then when you click on the div it will change to Thomas.\u003c/p\u003e\n\u003cp\u003eBut the thing to realise here is that useState is a global function. The value that's being stored or updated depends on the function that called useState which is essentially a local function but useState in itself is a global function. When you call the setState function, how does React know which components useState this call corresponds to.\u003c/p\u003e\n\u003cp\u003eThere's nothing you do in your component that tells useState \"Hey this function right here the reference to this function that's being run right now. This is what you need to rerender when i call the setState you give me.\" But there's no way to do this. There's no way for useState to implicitly get a reference to the function that's calling it. But there is another function that does know.\u003c/p\u003e\n\u003cp\u003eThe createElement() function is what actually calls the component function. So what we can do is make createElement update the global useState to be a function that stores state, generate a function that updates stored state and re runs the function component passed to createElement.\u003c/p\u003e\n\u003cp\u003eThe updated createElement will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst useState: (value: T)=\u003e[value, (value)=\u003evoid];\r\n\r\nfunction createElement(element, props, ...children){\r\n    if(typeof element === 'string'){\r\n        // This means this is an HTML Element\r\n\r\n        let e = document.createElement(element);\\\r\n\r\n        // Set attribute and event listeners according to the props\r\n        // e.setAttribute(\"\", \"\")\r\n        // e.onEvent(eventHandler)\r\n\r\n        // Append children to element\r\n        for(let child of children){\r\n            e.appendChild(child)\r\n        }\r\n\r\n        return e;\r\n    }else{\r\n        // This means a function component was passed\r\n\r\n        let componentStates = [];\r\n        let stateIndex = 0;\r\n        useState = (initialValue)=\u003e{\r\n            if(componentStates.length==stateIndex){\r\n                // This means this is the first time useState has been called for this state value\r\n                // So we store the initial value of state\r\n                componentStates.push(initialValue)\r\n            }\r\n            let currIndex = stateIndex;\r\n            stateIndex++;\r\n            return [\r\n                componentStates[currIndex],\r\n                (newValue)=\u003e{\r\n                    componentStates[currIndex] = newValue;\r\n                    element({...props, children})\r\n                }\r\n            ];\r\n        }\r\n        return element({...props, children});\r\n    }\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe createElement function isn't actually so simple, it also has the actual diff algorithm that compares old element type and new element type to figure out if it is a new element and if it isn't then to discard old state and so on. But I've skipped that bit for now.\u003c/p\u003e\n\u003cp\u003ecreateElement will maintain a list of state values of each component and useState will use and update that list of states to figure out whether to initialize state or to return existing state. stateIndex helps useState keep track of which state value is being initialized or updated. So when you update a state value, it calls the function again and this time when it calls useState it has the updated list of states.\u003c/p\u003e\n\u003cp\u003eThis is not actually how I implemented this functionality, the re-render wasn't called quite so simple either, especially with the complication we will be discussing next. I honestly don't remember how I did it and there's not way to know since I scrapped this and moved to a different approach which we will discuss to later.\u003c/p\u003e\n\u003cp\u003eNow it looks like state is implement, we call createElement, that sets up state vairables and the it calls the function component that calls useState and it's all hunky dory. Sadly no, if we go back to the original compiler output and examine the two compiled JSX lines.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Inside App\r\n    return createElement('div', {}, createElement(InternalComponent, {\"name\": \"George\"}));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen the createElement inside App is called, it will first evaluate the createElement function calls that are passed as children to it. That's just the order of evaluation that needs to happen. It cannot call the first createElement without first knowing everything that needs to be passed which means evaluating the second createElement. What this means is that in a given block of JSX, the createElement for children are evaluated before the parents and lastly the root element of that Block.\u003c/p\u003e\n\u003cp\u003eSo each time the a function component is rendered. This is what happens:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecreateElement for a the function component is first called.\u003c/li\u003e\n\u003cli\u003eThen the function component is called.\u003c/li\u003e\n\u003cli\u003eThen the return expression ie. the JSX block must be evaluated. This a series of createElement calls.\u003c/li\u003e\n\u003cli\u003eThe way it is structured, the createElements of the leaf nodes in the block of JSX needs to be evaluated first before it's parents within that JSX block can be executed.\u003c/li\u003e\n\u003cli\u003ecreateElements of the JSX block are called in a bottom up fashion.\u003c/li\u003e\n\u003cli\u003eWhenever a node within the JSX block is another function component, this cycle continues again for that function component before continuing with the original function components cycle.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhat this results in is a weird call system where the component functions are called in a sort of top-down manner but the createElements within a JSX block is called in a bottom-up manner. This was causing a huge problem when I implemented the useState function. I can't now recall what that huge problem is because that was back in November 2022 and now it's February 2023. Basically what happened was because of this fuck-all order of evaluation I wasn't able to call the right function component to re-render when setState was called. But looking at what I've written now I can't seem to figure out why that was the case.\u003c/p\u003e\n\u003cp\u003eNow it this next bit seems kind of useless because I can't remember what it actually solves....... but I guess we carry on anyway\u003c/p\u003e\n\u003cp\u003eWHat I think the problem was is..... I mentioned earlier on in the post that this createElement function also implemented the diff algorithm to make DOM manipulations. I've only written the creationof the element and the setting of attributes and listeners. Which is the part of the diff algorithm that runs when there was no existing element. When there already is one it compares and then either discards or retains the element and applies changes to it dynamically. The mixed up top-down manner of function component calls and and bottom up manner of the jsx evalution got in the way of the diff algorith working properly. So we needed to have everything be called in a proper top-down manner so that the diff will also take place in a top-down manner.\u003c/p\u003e\n\u003ch2\u003eHow react actually and re-renders each element\u003c/h2\u003e\n\u003cp\u003eOk we need it to only be top down, we can't have the JSX be evaluting itself in the bottom up manner. I don't know how I realsied this but I did. I realised that the evaluation of the child jsx elements needs to be run inside the evaluation of the parent jsx elements and not outide and before it. So internal createElements need to be deferred. But this isn't possible, the order of evaluation just won't allow for that.\u003c/p\u003e\n\u003cp\u003eBut if we really think about it, it's not that we want child createElements to be run by the parent. We want what createElement currently does for child elements to be called by parent elements. So what we need to do is move the component creation and evalution out of createElement. So what will createElement? Well in essence nothing. We ideally want it to return a function that then does what our original createElement did, let's call this the internal function. So now createElement no longer returns a child. Instead it returns a fucntion that creates a child. This also means that the children passed to a createElement call are not the actual children elements, they are functions that when called will return the corresponding child elements. So instead of just appending the child in the internal function like we do in the original createElement function, we must first run the function to get the element and then append it to the parent.\u003c/p\u003e\n\u003cp\u003eThis means that the node creation, setting of attributes and event listeners within a JSX block is now carried out in a top down manner becuase internal functions of children are only evaluated within the internal functions of parents.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst useState: (value: T)=\u003e[value, (value)=\u003evoid];\r\n\r\nfunction createElement(element, props, ...children){\r\n    return () =\u003e {\r\n        if(typeof element === 'string'){\r\n            // This means this is an HTML Element\r\n\r\n            let e = document.createElement(element);\\\r\n\r\n            // Set attribute and event listeners according to the props\r\n            // e.setAttribute(\"\", \"\")\r\n            // e.onEvent(eventHandler)\r\n\r\n            // Evaluate children and append to element\r\n            for(let child of children){\r\n                e.appendChild(child())\r\n            }\r\n\r\n            return e;\r\n        }else{\r\n            // This means a function component was passed\r\n\r\n            let componentStates = [];\r\n            let stateIndex = 0;\r\n            useState = (initialValue)=\u003e{\r\n                if(componentStates.length==stateIndex){\r\n                    // This means this is the first time useState has been called for this state value\r\n                    // So we store the initial value of state\r\n                    componentStates.push(initialValue)\r\n                }\r\n                let currIndex = stateIndex;\r\n                stateIndex++;\r\n                return [\r\n                    componentStates[currIndex],\r\n                    (newValue)=\u003e{\r\n                        componentStates[currIndex] = newValue;\r\n                        element({...props, children})\r\n                    }\r\n                ];\r\n            }\r\n            return element({...props, children});\r\n        }\r\n    };\r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReact actually doesn't do it like this. It actually separates the the createElement and internal function into two separate non-nested functions. createElement just returns and object of the element type, it's props and it's children in this same object format so it returns a recursive top down tree of the JSX block. This object is passed to a function ReactDOM.render, which carries out the function of the internal function we wrote and instead of calling the children functions, since they are not functions any more, now they are these tree objects, it calls ReactDOM.render on these children objects as well to get the corresponding HTML element to append to the child. We've all seen this ReactDOM.render element in the index.js file of our react apps.\u003c/p\u003e\n\u003cp\u003eFascinating stuff. I'm sure I made very little sense in this post but if you want a explaination feel free to hit me up on twitter.\u003c/p\u003e\n\u003cp\u003eWe're not done yet though, I decided to drop this approach. I realised that since I have to call createElement for every single jsx element in my app and run the diff algorithm on every single one of them(comparing old props and new props to know which attributes, styles and event handlers to change) and all this runs at runtime. The thing is that 90% of these elements never change in any of these aspects. Sure components might get added and removed depending on the state but when you take any single component about 90% of it is not state dependent. But the dynamic nature of the diff algorithm assumes every aspect of a component can be dependent on state and carries out these tree comparisons on ever single node. And this diff algorithm can be expensive, maybe not for 90% of projects out there becuase Virtual DOM diffing is still several degrees faster than HTMl DOM diffing. But when you consider how much of the diff actually results in DOM manipulations and how much of it leaves an HTML element as it is, you will realise just how much unnecessary work is being done in diffing static components.\u003c/p\u003e\n\u003cp\u003eSo I gave up and decided to go back to Vanilla Javascript. Until I thought of something else which we will talk about in Part-2.....\u003c/p\u003e\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"2023-02-22-lets-make-a-reactive-framework-pt-1"},"buildId":"1mZEgSQn3qenuh9xFH6Kn","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>